## üîç REVIEW CHECKLIST



### 1Ô∏è‚É£ **Architecture & Data Flow**

- Verify state management between `SessionStore`, `CustomerStore`, and the new `CRMService`.

- Ensure Gallery filters and search parameters map cleanly to Dexie queries.

- Confirm that session‚Äìcustomer linking maintains referential integrity (`customerId` in sessions table).

- Check that the proposed Dexie `version(3)` schema migration preserves old data.



### 2Ô∏è‚É£ **Component Hierarchy**

- Confirm React component hierarchy matches routing:

- `GalleryPage` ‚Üí `GridView` ‚Üí `SessionCard`

- `CRMPage` ‚Üí `CustomerList` / `CustomerDetail` / `CustomerEditor`

- Verify naming and folder structure align with Phase 3 conventions (`/src/pages`, `/src/components/gallery`, `/src/components/crm`).



### 3Ô∏è‚É£ **Service Layer**

- Validate that `CRMService.js` and `CustomerStore.js` functions are distinct and complementary.

- Confirm no redundant overlap with `SessionStore`.

- Check for async safety (await / Dexie query handling).



### 4Ô∏è‚É£ **Hooks & Utilities**

- Review the logic and parameters of `useSearchFilter.js`.

- Ensure hooks return stable outputs and avoid unnecessary re-renders.



### 5Ô∏è‚É£ **Debug & Logging**

- Ensure new domains `[GALLERY]` and `[CRM]` are consistently referenced through `useDebug()`.

- Confirm no console-only logs remain in production path.



---



## ‚öôÔ∏è REQUIRED OUTPUT FORMAT



At the end of your review, output a **structured summary** as follows:

‚úÖ Phase 4 Gemini Review Summary



‚úÖ Architecture Integrity

[Short assessment of data and state flow]



‚öôÔ∏è Implementation Notes

[List any areas that need clarification or slight revision before Grok build]



‚ö†Ô∏è Issues / Fixes Required

[List specific problems with imports, logic flow, or schema consistency]



üìã Files Verified

[List of all files reviewed and confirmed ready for Grok]

‚úÖ Status: [APPROVED / NEEDS REVISION]





---## üíæ NEXT STEPSAfter this review, the approved file will become:`PHASE 4 ‚Äî Gemini Code Review Summary.md`Then it will be passed back to **ChatGPT (Coordinator)** for patching and final delivery to **Grok** for implementation.---Use concise technical language ‚Äî no commentary or speculation ‚Äî and ensure your review covers all Phase 4 files.









PMC REVAMP ‚Äî PHASE 4: GALLERY & CRM INTEGRATION

Generated by Claude (Architect AI)

Date: 2025-10-11

üì¶ PHASE 4 OVERVIEW

Building on Phase 3 workflow, this phase implements:



Enhanced gallery with advanced filtering and search

Complete CRM system for customer management

Session-to-customer linking throughout workflow

Customer history tracking and analytics

Preparation for Phase 5 server sync

New Pages: 1 (CRMPage)

Enhanced Pages: 1 (GalleryPage)

New Components: 6

New Services: 1 (CRMService)

New Hooks: 1 (useSearchFilter)

Debug Domains: [GALLERY], [CRM]

üóÑÔ∏è DATABASE SCHEMA UPDATES

Migration to Version 3





javascript

// Update /src/services/database.js// Add new indices and fields for CRM featuresdb.version(3).stores({ photoSessions: 'sessionId, imageName, createdAt, currentVersion, hasTags, shareCount, lastSharedAt, customerId', deliveryJobs: 'jobId, sessionId, customerId, status, createdAt, nextAttemptAt, attempts', customers: 'customerId, name, phone, email, createdAt, lastContactAt, *linkedSessions, *tags', settings: 'id'}).upgrade(async tx => { // Add customerId field to existing sessions const sessions = await tx.table('photoSessions').toArray(); for (const session of sessions) { if (!session.customerId) { await tx.table('photoSessions').update(session.sessionId, { customerId: null }); } } // Add search tags to customers const customers = await tx.table('customers').toArray(); for (const customer of customers) { const searchTags = [ customer.name?.toLowerCase(), customer.phone, customer.email?.toLowerCase() ].filter(Boolean); await tx.table('customers').update(customer.customerId, { tags: searchTags, lastContactAt: customer.lastContactAt || customer.createdAt }); }});

New Fields Added:



photoSessions.customerId - Links session to customer

deliveryJobs.customerId - Track delivery recipient

customers.tags - Searchable text array

customers.lastContactAt - Last interaction timestamp

üìä DATA FLOW ARCHITECTURE

Gallery ‚Üî CRM ‚Üî Sessions Flow





‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ GalleryPage ‚îÇ‚îÇ (Grid View) ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îú‚îÄ‚Üí SessionStore.listSessions({ filters }) ‚îÇ ‚Üì sessions[] ‚îÇ ‚îú‚îÄ‚Üí CustomerStore.getCustomer(customerId) ‚îÇ ‚Üì customer ‚îÇ ‚îî‚îÄ‚Üí EventBus: 'session:created', 'customer:linked' ‚Üì refresh‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ CRMPage ‚îÇ‚îÇ (Customer Mgmt) ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îú‚îÄ‚Üí CustomerStore.listCustomers({ searchText }) ‚îÇ ‚Üì customers[] ‚îÇ ‚îú‚îÄ‚Üí CRMService.getCustomerAnalytics(customerId) ‚îÇ ‚Üì { sessionCount, deliveryCount, lastContact } ‚îÇ ‚îú‚îÄ‚Üí SessionStore.listSessions({ customerId }) ‚îÇ ‚Üì customer's sessions[] ‚îÇ ‚îî‚îÄ‚Üí EventBus: 'customer:updated', 'session:linked'‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ TaggingPage / ‚îÇ‚îÇ SharePage ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îú‚îÄ‚Üí CustomerStore.findCustomerByContact({ phone, email }) ‚îÇ ‚Üì existing customer or null ‚îÇ ‚îú‚îÄ‚Üí CustomerStore.addCustomer() / linkSessionToCustomer() ‚îÇ ‚Üì customerId ‚îÇ ‚îî‚îÄ‚Üí EventBus.emit('customer:linked', { sessionId, customerId })

FILE: /src/services/database.js





javascript

// File: /src/services/database.js// Purpose: Update Dexie schema to version 3 with CRM enhancements// Connects to: All storesimport Dexie from 'dexie';export const db = new Dexie('PMCRevampDB');// Version 3: CRM Integrationdb.version(3).stores({ photoSessions: 'sessionId, imageName, createdAt, currentVersion, hasTags, shareCount, lastSharedAt, customerId', deliveryJobs: 'jobId, sessionId, customerId, status, createdAt, nextAttemptAt, attempts', customers: 'customerId, name, phone, email, createdAt, lastContactAt, *linkedSessions, *tags', settings: 'id'}).upgrade(async tx => { // Migration logic for adding customerId to sessions const sessions = await tx.table('photoSessions').toArray(); for (const session of sessions) { if (!session.customerId) { await tx.table('photoSessions').update(session.sessionId, { customerId: null }); } } // Add searchable tags to customers const customers = await tx.table('customers').toArray(); for (const customer of customers) { const searchTags = [ customer.name?.toLowerCase(), customer.phone, customer.email?.toLowerCase() ].filter(Boolean); await tx.table('customers').update(customer.customerId, { tags: searchTags, lastContactAt: customer.lastContactAt || customer.createdAt }); }});// Keep previous versions for migration pathdb.version(2).stores({ photoSessions: 'sessionId, imageName, createdAt, currentVersion, hasTags, shareCount, lastSharedAt', deliveryJobs: 'jobId, sessionId, status, createdAt, nextAttemptAt, attempts', customers: 'customerId, name, phone, email, createdAt, *linkedSessions', settings: 'id'});db.version(1).stores({ sessions: '++id, sessionId, fileName, uploadDate, status, *tags', tags_meta: '++id, sessionId, tagId, text, x, y, fontSize, color, fontFamily', customers: '++id, name, phone, email, lastDelivery, status', delivery_queue: '++id, sessionId, customerId, status, queuedAt, sentAt, retryCount', settings: 'key, value'});db.on('ready', () => { console.log('[DB] Database ready - version', db.verno);});db.on('populate', () => { // Initialize settings (already handled in v2)});db.on('error', (error) => { console.error('[DB] Database error:', error);});export default db;

Notes: Version 3 adds customerId linking and searchable customer tags; maintains backward compatibility.

FILE: /src/services/SessionStore.js





javascript

// File: /src/services/SessionStore.js// Purpose: Enhanced session operations with customer linking and advanced queries// Connects to: database.js, EventBus.js// [Existing functions from Phase 2 remain...]/** * List sessions by customer ID * @param {string} customerId * @returns {Promise<Array>} */export async function listSessionsByCustomer(customerId) { try { return await db.photoSessions .where('customerId') .equals(customerId) .reverse() .sortBy('createdAt'); } catch (error) { console.error('[SessionStore] Error listing sessions by customer:', error); return []; }}/** * Link session to customer * @param {string} sessionId * @param {string} customerId */export async function linkSessionToCustomer(sessionId, customerId) { try { await db.photoSessions.update(sessionId, { customerId }); emit('session:linked', { sessionId, customerId }); } catch (error) { console.error('[SessionStore] Error linking session:', error); throw error; }}/** * Get sessions by date range * @param {number} startDate - Timestamp * @param {number} endDate - Timestamp * @returns {Promise<Array>} */export async function listSessionsByDateRange(startDate, endDate) { try { return await db.photoSessions .where('createdAt') .between(startDate, endDate) .reverse() .sortBy('createdAt'); } catch (error) { console.error('[SessionStore] Error getting sessions by date:', error); return []; }}/** * Get session with customer info * @param {string} sessionId * @returns {Promise<Object>} */export async function getSessionWithCustomer(sessionId) { try { const session = await getSession(sessionId); if (!session) return null; if (session.customerId) { const { getCustomer } = await import('./CustomerStore.js'); const customer = await getCustomer(session.customerId); return { ...session, customer }; } return session; } catch (error) { console.error('[SessionStore] Error getting session with customer:', error); return null; }}// Export new functionsexport default { // ... existing exports listSessionsByCustomer, linkSessionToCustomer, listSessionsByDateRange, getSessionWithCustomer};

Notes: Adds customer-aware queries; maintains existing Phase 2 functionality.

FILE: /src/services/CustomerStore.js





javascript

// File: /src/services/CustomerStore.js// Purpose: Enhanced customer operations with analytics and session tracking// Connects to: database.js, EventBus.js// [Existing functions from Phase 2 remain...]/** * Get customer with linked sessions * @param {string} customerId * @returns {Promise<Object>} */export async function getCustomerWithSessions(customerId) { try { const customer = await getCustomer(customerId); if (!customer) return null; const { listSessionsByCustomer } = await import('./SessionStore.js'); const sessions = await listSessionsByCustomer(customerId); return { ...customer, sessions, sessionCount: sessions.length }; } catch (error) { console.error('[CustomerStore] Error getting customer with sessions:', error); return null; }}/** * Search customers (supports partial matching) * @param {string} query * @returns {Promise<Array>} */export async function searchCustomers(query) { try { if (!query) return await listCustomers(); const lowerQuery = query.toLowerCase(); // Search using tags array const results = await db.customers .where('tags') .startsWithAnyOf(lowerQuery) .toArray(); // Also do manual filter for partial matches const allCustomers = await db.customers.toArray(); const filtered = allCustomers.filter(c => c.name?.toLowerCase().includes(lowerQuery) || c.phone?.includes(query) || c.email?.toLowerCase().includes(lowerQuery) ); // Merge and deduplicate const uniqueIds = new Set(); const merged = []; [...results, ...filtered].forEach(customer => { if (!uniqueIds.has(customer.customerId)) { uniqueIds.add(customer.customerId); merged.push(customer); } }); return merged; } catch (error) { console.error('[CustomerStore] Error searching customers:', error); return []; }}/** * Update customer tags for search * @param {string} customerId */async function updateCustomerTags(customerId) { try { const customer = await getCustomer(customerId); if (!customer) return; const tags = [ customer.name?.toLowerCase(), customer.phone, customer.email?.toLowerCase() ].filter(Boolean); await db.customers.update(customerId, { tags }); } catch (error) { console.error('[CustomerStore] Error updating tags:', error); }}// Override updateCustomer to refresh tagsexport async function updateCustomer(customerId, updates) { try { await db.customers.update(customerId, updates); await updateCustomerTags(customerId); emit('customer:updated', { customerId, updates }); } catch (error) { console.error('[CustomerStore] Error updating customer:', error); throw error; }}// Export enhanced functionsexport default { // ... existing exports getCustomerWithSessions, searchCustomers};

Notes: Adds search optimization and session integration; tags auto-update on edit.

FILE: /src/services/CRMService.js





javascript

// File: /src/services/CRMService.js// Purpose: High-level CRM operations and analytics// Connects to: CustomerStore, SessionStore, DeliveryQueueimport { getCustomerWithSessions, listCustomers } from './CustomerStore';import { listSessionsByCustomer } from './SessionStore';import { getJobsBySession } from './DeliveryQueue';/** * Get customer analytics * @param {string} customerId * @returns {Promise<Object>} */export async function getCustomerAnalytics(customerId) { try { const customer = await getCustomerWithSessions(customerId); if (!customer) return null; const sessions = customer.sessions || []; // Count deliveries let deliveryCount = 0; for (const session of sessions) { const jobs = await getJobsBySession(session.sessionId); deliveryCount += jobs.filter(j => j.status === 'completed').length; } // Calculate stats const taggedSessions = sessions.filter(s => s.hasTags).length; const sharedSessions = sessions.filter(s => s.shareCount > 0).length; const totalShares = sessions.reduce((sum, s) => sum + (s.shareCount || 0), 0); return { customerId, sessionCount: sessions.length, taggedSessionCount: taggedSessions, sharedSessionCount: sharedSessions, totalShares, deliveryCount, lastContact: customer.lastContactAt, averageSharesPerSession: sessions.length > 0 ? totalShares / sessions.length : 0 }; } catch (error) { console.error('[CRMService] Error getting analytics:', error); return null; }}/** * Get CRM dashboard stats * @returns {Promise<Object>} */export async function getCRMStats() { try { const customers = await listCustomers(); const withSessions = customers.filter(c => c.linkedSessions && c.linkedSessions.length > 0).length; const withDeliveries = customers.filter(c => c.deliveryCount > 0).length; const recentlyActive = customers.filter(c => { const daysSince = (Date.now() - (c.lastContactAt || c.createdAt)) / (1000 * 60 * 60 * 24); return daysSince <= 30; }).length; return { total: customers.length, withSessions, withDeliveries, recentlyActive }; } catch (error) { console.error('[CRMService] Error getting CRM stats:', error); return { total: 0, withSessions: 0, withDeliveries: 0, recentlyActive: 0 }; }}/** * Merge duplicate customers * @param {string} primaryId * @param {string} duplicateId */export async function mergeCustomers(primaryId, duplicateId) { try { const [primary, duplicate] = await Promise.all([ getCustomerWithSessions(primaryId), getCustomerWithSessions(duplicateId) ]); if (!primary || !duplicate) { throw new Error('One or both customers not found'); } // Merge sessions const allSessions = [...(primary.linkedSessions || []), ...(duplicate.linkedSessions || [])]; const uniqueSessions = [...new Set(allSessions)]; // Update all sessions to point to primary const { db } = await import('./database'); for (const sessionId of duplicate.linkedSessions || []) { await db.photoSessions.update(sessionId, { customerId: primaryId }); } // Update primary customer await db.customers.update(primaryId, { linkedSessions: uniqueSessions, deliveryCount: (primary.deliveryCount || 0) + (duplicate.deliveryCount || 0), notes: [primary.notes, duplicate.notes].filter(Boolean).join('\n---\n') }); // Delete duplicate const { deleteCustomer } = await import('./CustomerStore'); await deleteCustomer(duplicateId); return { success: true, mergedSessionCount: duplicate.linkedSessions?.length || 0 }; } catch (error) { console.error('[CRMService] Error merging customers:', error); throw error; }}export default { getCustomerAnalytics, getCRMStats, mergeCustomers};

Notes: Provides aggregation layer; keeps stores focused on CRUD only.

FILE: /src/hooks/useSearchFilter.js





javascript

// File: /src/hooks/useSearchFilter.js// Purpose: Reusable search and filter logic for lists// Connects to: GalleryPage, CRMPageimport { useState, useEffect, useMemo } from 'react';import { debounce } from '../utils/helpers';/** * Search and filter hook * @param {Array} items - Items to filter * @param {Object} options - { searchFields, filterFn, debounceMs } * @returns {Object} { filteredItems, searchText, setSearchText, filters, setFilters } */export function useSearchFilter(items, options = {}) { const { searchFields = ['name'], filterFn = null, debounceMs = 300 } = options; const [searchText, setSearchText] = useState(''); const [debouncedSearch, setDebouncedSearch] = useState(''); const [filters, setFilters] = useState({}); // Debounce search text useEffect(() => { const handler = debounce(() => { setDebouncedSearch(searchText); }, debounceMs); handler(); }, [searchText, debounceMs]); // Filter items const filteredItems = useMemo(() => { let result = items; // Apply search if (debouncedSearch) { const lowerSearch = debouncedSearch.toLowerCase(); result = result.filter(item => searchFields.some(field => { const value = field.split('.').reduce((obj, key) => obj?.[key], item); return value?.toString().toLowerCase().includes(lowerSearch); }) ); } // Apply custom filter function if (filterFn) { result = result.filter(item => filterFn(item, filters)); } return result; }, [items, debouncedSearch, filters, searchFields, filterFn]); return { filteredItems, searchText, setSearchText, filters, setFilters, resultCount: filteredItems.length, totalCount: items.length };}export default useSearchFilter;

Notes: Generic hook for search/filter; works with any array of objects.

FILE: /src/pages/GalleryPage.jsx





javascript

// File: /src/pages/GalleryPage.jsx// Purpose: Enhanced gallery with filters, search, and customer info display// Connects to: SessionStore, CustomerStore, EventBus, useDebug, gallery componentsimport React, { useState, useEffect } from 'react';import { useNavigate } from 'react-router-dom';import useDebug from '../debug/useDebug';import useSearchFilter from '../hooks/useSearchFilter';import { listSessions, getSessionStats } from '../services/SessionStore';import { on, off } from '../services/EventBus';import FilterBar from '../components/gallery/FilterBar';import GridView from '../components/gallery/GridView';function GalleryPage() { const navigate = useNavigate(); const debug = useDebug('GALLERY'); const [sessions, setSessions] = useState([]); const [stats, setStats] = useState({ total: 0, raw: 0, tagged: 0, shared: 0 }); const [isLoading, setIsLoading] = useState(true); const [viewMode, setViewMode] = useState('grid'); // 'grid' or 'list' // Search and filter hook const { filteredItems: filteredSessions, searchText, setSearchText, filters, setFilters, resultCount } = useSearchFilter(sessions, { searchFields: ['imageName', 'tagsMeta.text'], filterFn: (session, filters) => { if (filters.status && filters.status !== 'all') { if (filters.status === 'raw' && session.hasTags) return false; if (filters.status === 'tagged' && !session.hasTags) return false; if (filters.status === 'shared' && session.shareCount === 0) return false; } if (filters.dateRange) { const { start, end } = filters.dateRange; if (session.createdAt < start || session.createdAt > end) return false; } if (filters.hasCustomer !== undefined) { if (filters.hasCustomer && !session.customerId) return false; if (!filters.hasCustomer && session.customerId) return false; } return true; } }); useEffect(() => { loadSessions(); // Subscribe to events const unsubscribes = [ on('session:created', handleSessionEvent), on('tags:updated', handleSessionEvent), on('share:completed', handleSessionEvent), on('session:deleted', handleSessionEvent), on('session:linked', handleSessionEvent), on('customer:updated', handleSessionEvent) ]; return () => unsubscribes.forEach(unsub => unsub()); }, []); useEffect(() => { loadStats(); }, [sessions]); const loadSessions = async () => { debug.time('load_gallery'); debug.log('load_start'); try { const data = await listSessions(); setSessions(data); debug.timeEnd('load_gallery', { count: data.length }); debug.success('gallery_loaded', { count: data.length }); setIsLoading(false); } catch (error) { debug.error('load_failed', { error: error.message }); setIsLoading(false); } }; const loadStats = async () => { const data = await getSessionStats(); setStats(data); }; const handleSessionEvent = (payload) => { debug.log('event_received', { event: payload._event }); loadSessions(); }; const handleSessionClick = (sessionId) => { debug.log('session_opened', { sessionId }); navigate(`/share/${sessionId}`); }; const handleEditClick = (sessionId, e) => { e.stopPropagation(); navigate(`/tag/${sessionId}`); }; if (isLoading) { return ( <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4"> <div className="text-center"> <div className="text-5xl mb-4">‚è≥</div> <p className="text-gray-600">Loading gallery...</p> </div> </div> ); } return ( <div className="min-h-screen bg-gray-50 pb-20"> {/* Header */} <div className="bg-white border-b border-gray-200 sticky top-0 z-10"> <div className="p-4"> <div className="flex items-center justify-between mb-4"> <h1 className="text-2xl font-bold text-gray-800">üñºÔ∏è Gallery</h1> <button onClick={() => navigate('/upload')} className=" px-4 py-2 bg-primary text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 transition-colors text-sm min-h-[44px] shadow-sm " > + Upload </button> </div> {/* Filter Bar */} <FilterBar stats={stats} searchText={searchText} onSearchChange={setSearchText} filters={filters} onFiltersChange={setFilters} viewMode={viewMode} onViewModeChange={setViewMode} resultCount={resultCount} /> </div> </div> {/* Content */} <div className="p-4"> {filteredSessions.length === 0 ? ( <div className="text-center py-12"> <div className="text-6xl mb-4"> {sessions.length === 0 ? 'üì∑' : 'üîç'} </div> <p className="text-gray-600 mb-4"> {sessions.length === 0 ? 'No sessions yet' : 'No sessions match your filters'} </p> {sessions.length === 0 && ( <button onClick={() => navigate('/upload')} className=" px-6 py-3 bg-primary text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 transition-colors " > Upload First Photo </button> )} </div> ) : ( <GridView sessions={filteredSessions} viewMode={viewMode} onSessionClick={handleSessionClick} onEditClick={handleEditClick} /> )} </div> </div> );}export default GalleryPage;

Notes: Integrates useSearchFilter hook; supports grid/list views; customer info display.

FILE: /src/components/gallery/FilterBar.jsx





javascript

// File: /src/components/gallery/FilterBar.jsx// Purpose: Search, filter, and view mode controls for gallery// Connects to: GalleryPageimport React from 'react';function FilterBar({ stats, searchText, onSearchChange, filters, onFiltersChange, viewMode, onViewModeChange, resultCount}) { const statusOptions = [ { key: 'all', label: 'All', count: stats.total }, { key: 'raw', label: 'Raw', count: stats.raw }, { key: 'tagged', label: 'Tagged', count: stats.tagged }, { key: 'shared', label: 'Shared', count: stats.shared } ]; return ( <div className="space-y-3"> {/* Status Filter Pills */} <div className="flex items-center gap-2 overflow-x-auto pb-2 -mx-2 px-2"> {statusOptions.map(option => ( <button key={option.key} onClick={() => onFiltersChange({ ...filters, status: option.key })} className={` flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-colors touch-manipulation ${filters.status === option.key || (!filters.status && option.key === 'all') ? 'bg-primary text-white' : 'bg-gray-100 text-gray-700 hover:bg-gray-200' } `} > {option.label} ({option.count}) </button> ))} </div> {/* Search Bar */} <div className="flex items-center gap-2"> <div className="flex-1 relative"> <input type="text" value={searchText} onChange={(e) => onSearchChange(e.target.value)} placeholder="Search by filename or tag..." className=" w-full px-4 py-3 pl-10 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base min-h-[48px] " /> <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"> üîç </span> </div> {/* View Mode Toggle */} <div className="flex items-center bg-gray-100 rounded-lg p-1"> <button onClick={() => onViewModeChange('grid')} className={` p-2 rounded transition-colors min-h-[40px] min-w-[40px] ${viewMode === 'grid' ? 'bg-white shadow-sm' : 'text-gray-600'} `} > ‚ñ¶ </button> <button onClick={() => onViewModeChange('list')} className={` p-2 rounded transition-colors min-h-[40px] min-w-[40px] ${viewMode === 'list' ? 'bg-white shadow-sm' : 'text-gray-600'} `} > ‚ò∞ </button> </div> </div> {/* Result Count */} {searchText && ( <p className="text-xs text-gray-500"> Showing {resultCount} of {stats.total} sessions </p> )} {/* Advanced Filters Toggle */} <details className="text-sm"> <summary className="cursor-pointer text-primary hover:text-blue-600 select-none"> Advanced Filters </summary> <div className="mt-3 space-y-2 p-3 bg-gray-50 rounded-lg"> <label className="flex items-center space-x-2 touch-manipulation min-h-[44px]"> <input type="checkbox" checked={filters.hasCustomer === true} onChange={(e) => onFiltersChange({ ...filters, hasCustomer: e.target.checked ? true : undefined })} className="w-4 h-4" /> <span>Only with customer</span> </label> </div> </details> </div> );}export default FilterBar;

Notes: Horizontal scrolling filter pills; expandable advanced filters; view mode toggle.

FILE: /src/components/gallery/GridView.jsx





javascript

// File: /src/components/gallery/GridView.jsx// Purpose: Responsive grid layout for session cards// Connects to: GalleryPage, SessionCardimport React from 'react';import SessionCard from './SessionCard';function GridView({ sessions, viewMode, onSessionClick, onEditClick }) { if (viewMode === 'list') { return ( <div className="space-y-3"> {sessions.map(session => ( <SessionCard key={session.sessionId} session={session} viewMode="list" onClick={() => onSessionClick(session.sessionId)} onEdit={(e) => onEditClick(session.sessionId, e)} /> ))} </div> ); } return ( <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4"> {sessions.map(session => ( <SessionCard key={session.sessionId} session={session} viewMode="grid" onClick={() => onSessionClick(session.sessionId)} onEdit={(e) => onEditClick(session.sessionId, e)} /> ))} </div> );}export default GridView;

Notes: Switches between grid and list layouts; responsive breakpoints.

FILE: /src/components/gallery/SessionCard.jsx





javascript

// File: /src/components/gallery/SessionCard.jsx// Purpose: Session thumbnail card with status badges and customer info// Connects to: GridView, SessionStore, CustomerStoreimport React, { useState, useEffect } from 'react';import { blobToDataURL } from '../../services/ImageService';import { getCustomer } from '../../services/CustomerStore';import { deleteSession } from '../../services/SessionStore';import { formatRelativeTime } from '../../utils/helpers';import useDebug from '../../debug/useDebug';function SessionCard({ session, viewMode, onClick, onEdit }) { const debug = useDebug('GALLERY'); const [thumbUrl, setThumbUrl] = useState(null); const [customer, setCustomer] = useState(null); const [showActions, setShowActions] = useState(false); useEffect(() => { loadThumb(); if (session.customerId) { loadCustomer(); } }, [session]); const loadThumb = async () => { try { const blob = session.currentVersion === 'tagged' && session.taggedThumbBlob ? session.taggedThumbBlob : session.rawThumbBlob; const url = await blobToDataURL(blob); setThumbUrl(url); } catch (error) { debug.error('thumb_load_failed', { sessionId: session.sessionId, error: error.message }); } }; const loadCustomer = async () => { try { const customerData = await getCustomer(session.customerId); setCustomer(customerData); } catch (error) { debug.error('customer_load_failed', { customerId: session.customerId }); } }; const handleDelete = async (e) => { e.stopPropagation(); if (!confirm('Delete this session?')) return; try { await deleteSession(session.sessionId); debug.success('session_deleted', { sessionId: session.sessionId }); } catch (error) { debug.error('delete_failed', { sessionId: session.sessionId, error: error.message }); } }; if (viewMode === 'list') { return ( <div onClick={onClick} className=" bg-white rounded-lg shadow-sm hover:shadow-md transition-shadow cursor-pointer touch-manipulation flex items-center p-3 gap-4 " > {/* Thumbnail */} <div className="w-20 h-20 flex-shrink-0 bg-gray-100 rounded overflow-hidden"> {thumbUrl && ( <img src={thumbUrl} alt={session.imageName} className="w-full h-full object-cover" /> )} </div> {/* Info */} <div className="flex-1 min-w-0"> <p className="font-medium text-gray-800 truncate text-sm"> {session.imageName} </p> {customer && ( <p className="text-xs text-gray-500 truncate"> üë§ {customer.name} </p> )} <p className="text-xs text-gray-400"> {formatRelativeTime(session.createdAt)} </p> </div> {/* Status Badges */} <div className="flex flex-col items-end gap-1"> {session.hasTags && ( <span className="px-2 py-1 bg-primary text-white text-xs rounded-full"> üè∑Ô∏è </span> )} {session.shareCount > 0 && ( <span className="px-2 py-1 bg-green-500 text-white text-xs rounded-full"> üì§ {session.shareCount} </span> )} </div> </div> ); } // Grid view return ( <div onClick={onClick} onMouseEnter={() => setShowActions(true)} onMouseLeave={() => setShowActions(false)} className=" bg-white rounded-lg shadow-md overflow-hidden cursor-pointer hover:shadow-lg active:shadow-sm transition-shadow touch-manipulation relative " > {/* Thumbnail */} <div className="relative aspect-square bg-gray-100"> {thumbUrl && ( <img src={thumbUrl} alt={session.imageName} className="w-full h-full object-cover" /> )} {/* Status Badges */} <div className="absolute top-2 right-2 flex flex-col gap-1"> {session.hasTags && ( <span className="px-2 py-1 bg-primary text-white text-xs rounded-full shadow-sm"> üè∑Ô∏è Tagged </span> )} {session.shareCount > 0 && ( <span className="px-2 py-1 bg-green-500 text-white text-xs rounded-full shadow-sm"> üì§ {session.shareCount} </span> )} </div> {/* Action Buttons (hover/touch) */} <div className={` absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center gap-2 transition-opacity ${showActions ? 'opacity-100' : 'opacity-0 pointer-events-none'} `} > <button onClick={onEdit} className=" px-3 py-2 bg-white text-gray-800 rounded-lg text-sm font-medium hover:bg-gray-100 active:bg-gray-200 pointer-events-auto " > Edit </button> <button onClick={handleDelete} className=" p-2 bg-red-500 text-white rounded-lg hover:bg-red-600 active:bg-red-700 pointer-events-auto min-h-[36px] min-w-[36px] " > üóëÔ∏è </button> </div> </div> {/* Info */} <div className="p-3"> <p className="text-sm font-medium text-gray-800 truncate"> {session.imageName} </p> {customer && ( <p className="text-xs text-gray-600 truncate mt-1"> üë§ {customer.name} </p> )} <p className="text-xs text-gray-500 mt-1"> {formatRelativeTime(session.createdAt)} </p> </div> </div> );}export default SessionCard;

Notes: Dual layout support (grid/list); shows customer name; hover actions on desktop.

FILE: /src/pages/CRMPage.jsx





javascript

// File: /src/pages/CRMPage.jsx// Purpose: Customer relationship management interface with list, search, and detail views// Connects to: CustomerStore, CRMService, SessionStore, useDebug, CRM componentsimport React, { useState, useEffect } from 'react';import { useNavigate, useSearchParams } from 'react-router-dom';import useDebug from '../debug/useDebug';import useSearchFilter from '../hooks/useSearchFilter';import { listCustomers } from '../services/CustomerStore';import { getCRMStats } from '../services/CRMService';import { on, off } from '../services/EventBus';import CustomerList from '../components/crm/CustomerList';import CustomerDetail from '../components/crm/CustomerDetail';import CustomerEditor from '../components/crm/CustomerEditor';function CRMPage() { const navigate = useNavigate(); const [searchParams, setSearchParams] = useSearchParams(); const debug = useDebug('CRM'); const [customers, setCustomers] = useState([]); const [stats, setStats] = useState({ total: 0, withSessions: 0, withDeliveries: 0, recentlyActive: 0 }); const [selectedCustomerId, setSelectedCustomerId] = useState(searchParams.get('id')); const [isEditing, setIsEditing] = useState(false); const [isLoading, setIsLoading] = useState(true); // Search hook const { filteredItems: filteredCustomers, searchText, setSearchText, resultCount } = useSearchFilter(customers, { searchFields: ['name', 'phone', 'email'] }); useEffect(() => { loadCustomers(); loadStats(); // Subscribe to events const unsubscribes = [ on('customer:created', handleCustomerEvent), on('customer:updated', handleCustomerEvent), on('customer:deleted', handleCustomerEvent), on('session:linked', handleCustomerEvent) ]; return () => unsubscribes.forEach(unsub => unsub()); }, []); useEffect(() => { if (selectedCustomerId) { setSearchParams({ id: selectedCustomerId }); } else { setSearchParams({}); } }, [selectedCustomerId]); const loadCustomers = async () => { debug.time('load_customers'); debug.log('load_start'); try { const data = await listCustomers(); setCustomers(data); debug.timeEnd('load_customers', { count: data.length }); debug.success('customers_loaded', { count: data.length }); setIsLoading(false); } catch (error) { debug.error('load_failed', { error: error.message }); setIsLoading(false); } }; const loadStats = async () => { const data = await getCRMStats(); setStats(data); }; const handleCustomerEvent = (payload) => { debug.log('event_received', { event: payload._event }); loadCustomers(); loadStats(); }; const handleCustomerSelect = (customerId) => { setSelectedCustomerId(customerId); setIsEditing(false); }; const handleNewCustomer = () => { setSelectedCustomerId(null); setIsEditing(true); }; const handleEdit = () => { setIsEditing(true); }; const handleSave = () => { setIsEditing(false); loadCustomers(); }; const handleCancel = () => { setIsEditing(false); if (!selectedCustomerId) { setSelectedCustomerId(null); } }; if (isLoading) { return ( <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4"> <div className="text-center"> <div className="text-5xl mb-4">‚è≥</div> <p className="text-gray-600">Loading customers...</p> </div> </div> ); } return ( <div className="min-h-screen bg-gray-50"> {/* Header */} <div className="bg-white border-b border-gray-200 sticky top-0 z-10"> <div className="p-4"> <div className="flex items-center justify-between mb-4"> <h1 className="text-2xl font-bold text-gray-800">üë• CRM</h1> <button onClick={handleNewCustomer} className=" px-4 py-2 bg-primary text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 transition-colors text-sm min-h-[44px] shadow-sm " > + Add Customer </button> </div> {/* Stats */} <div className="grid grid-cols-4 gap-2 mb-4"> {[ { label: 'Total', value: stats.total }, { label: 'w/ Sessions', value: stats.withSessions }, { label: 'w/ Deliveries', value: stats.withDeliveries }, { label: 'Active (30d)', value: stats.recentlyActive } ].map(stat => ( <div key={stat.label} className="p-3 bg-gray-100 rounded-lg text-center"> <div className="text-lg font-bold text-gray-800">{stat.value}</div> <div className="text-xs text-gray-600">{stat.label}</div> </div> ))} </div> {/* Search */} <input type="text" value={searchText} onChange={(e) => setSearchText(e.target.value)} placeholder="Search customers..." className=" w-full px-4 py-3 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base min-h-[48px] " /> {searchText && ( <p className="text-xs text-gray-500 mt-2"> Showing {resultCount} of {stats.total} customers </p> )} </div> </div> {/* Content */} <div className="p-4 lg:flex lg:gap-6"> {/* Customer List (Left Panel) */} <div className="lg:w-1/3 mb-6 lg:mb-0"> <CustomerList customers={filteredCustomers} selectedCustomerId={selectedCustomerId} onSelectCustomer={handleCustomerSelect} /> </div> {/* Detail/Editor (Right Panel) */} <div className="lg:flex-1"> {isEditing ? ( <CustomerEditor customerId={selectedCustomerId} onSave={handleSave} onCancel={handleCancel} /> ) : selectedCustomerId ? ( <CustomerDetail customerId={selectedCustomerId} onEdit={handleEdit} onClose={() => setSelectedCustomerId(null)} /> ) : ( <div className="bg-white rounded-lg shadow-md p-12 text-center"> <div className="text-6xl mb-4">üë§</div> <p className="text-gray-600 mb-4">Select a customer to view details</p> <button onClick={handleNewCustomer} className=" px-6 py-3 bg-primary text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 transition-colors " > Add New Customer </button> </div> )} </div> </div> </div> );}export default CRMPage;

Notes: Two-panel layout; master-detail pattern; real-time EventBus updates.

FILE: /src/components/crm/CustomerList.jsx





javascript

// File: /src/components/crm/CustomerList.jsx// Purpose: Scrollable list of customer cards// Connects to: CRMPageimport React from 'react';import { formatRelativeTime } from '../../utils/helpers';function CustomerList({ customers, selectedCustomerId, onSelectCustomer }) { if (customers.length === 0) { return ( <div className="bg-white rounded-lg shadow-md p-8 text-center"> <div className="text-4xl mb-2">üìã</div> <p className="text-gray-600 text-sm">No customers found</p> </div> ); } return ( <div className="space-y-2 max-h-[70vh] overflow-y-auto"> {customers.map(customer => ( <div key={customer.customerId} onClick={() => onSelectCustomer(customer.customerId)} className={` bg-white rounded-lg shadow-sm p-4 cursor-pointer transition-all touch-manipulation ${selectedCustomerId === customer.customerId ? 'ring-2 ring-primary shadow-md' : 'hover:shadow-md' } `} > <div className="flex items-start justify-between"> <div className="flex-1 min-w-0"> <p className="font-medium text-gray-800 truncate"> {customer.name || 'Unnamed Customer'} </p> {customer.phone && ( <p className="text-sm text-gray-600 truncate"> üìû {customer.phone} </p> )} {customer.email && ( <p className="text-sm text-gray-600 truncate"> üìß {customer.email} </p> )} {customer.lastContactAt && ( <p className="text-xs text-gray-400 mt-1"> Last contact: {formatRelativeTime(customer.lastContactAt)} </p> )} </div> {/* Badges */} <div className="flex flex-col items-end gap-1 ml-2"> {customer.linkedSessions && customer.linkedSessions.length > 0 && ( <span className="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded-full"> {customer.linkedSessions.length} sessions </span> )} {customer.deliveryCount > 0 && ( <span className="px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full"> {customer.deliveryCount} deliveries </span> )} </div> </div> </div> ))} </div> );}export default CustomerList;

Notes: Compact card layout; shows key info and badges; scrollable.

FILE: /src/components/crm/CustomerDetail.jsx





javascript

// File: /src/components/crm/CustomerDetail.jsx// Purpose: Full customer details with analytics and session list// Connects to: CRMPage, CustomerStore, CRMService, SessionStoreimport React, { useState, useEffect } from 'react';import { useNavigate } from 'react-router-dom';import { getCustomerWithSessions } from '../../services/CustomerStore';import { getCustomerAnalytics } from '../../services/CRMService';import { blobToDataURL } from '../../services/ImageService';import { formatDate, formatRelativeTime } from '../../utils/helpers';import useDebug from '../../debug/useDebug';function CustomerDetail({ customerId, onEdit, onClose }) { const navigate = useNavigate(); const debug = useDebug('CRM'); const [customer, setCustomer] = useState(null); const [analytics, setAnalytics] = useState(null); const [sessionThumbs, setSessionThumbs] = useState({}); const [isLoading, setIsLoading] = useState(true); useEffect(() => { loadCustomer(); }, [customerId]); const loadCustomer = async () => { debug.time('load_customer_detail'); debug.log('load_detail_start', { customerId }); try { const [customerData, analyticsData] = await Promise.all([ getCustomerWithSessions(customerId), getCustomerAnalytics(customerId) ]); setCustomer(customerData); setAnalytics(analyticsData); // Load session thumbnails if (customerData.sessions) { const thumbs = {}; for (const session of customerData.sessions.slice(0, 6)) { const url = await blobToDataURL(session.rawThumbBlob); thumbs[session.sessionId] = url; } setSessionThumbs(thumbs); } debug.timeEnd('load_customer_detail', { customerId }); setIsLoading(false); } catch (error) { debug.error('load_detail_failed', { customerId, error: error.message }); setIsLoading(false); } }; if (isLoading) { return ( <div className="bg-white rounded-lg shadow-md p-12 text-center"> <div className="text-4xl mb-4">‚è≥</div> <p className="text-gray-600">Loading...</p> </div> ); } if (!customer) { return ( <div className="bg-white rounded-lg shadow-md p-12 text-center"> <div className="text-4xl mb-4">‚ùå</div> <p className="text-gray-600">Customer not found</p> </div> ); } return ( <div className="bg-white rounded-lg shadow-md overflow-hidden"> {/* Header */} <div className="bg-gray-800 text-white p-6"> <div className="flex items-start justify-between"> <div className="flex-1"> <h2 className="text-2xl font-bold mb-2">{customer.name}</h2> {customer.phone && <p className="text-gray-300 mb-1">üìû {customer.phone}</p>} {customer.email && <p className="text-gray-300">üìß {customer.email}</p>} </div> <div className="flex gap-2"> <button onClick={onEdit} className=" px-4 py-2 bg-white text-gray-800 rounded-lg font-medium hover:bg-gray-100 active:bg-gray-200 transition-colors text-sm min-h-[40px] " > Edit </button> <button onClick={onClose} className=" p-2 text-white hover:bg-gray-700 rounded-lg min-h-[40px] min-w-[40px] " > √ó </button> </div> </div> </div> {/* Analytics */} <div className="p-6 border-b border-gray-200"> <h3 className="font-semibold text-gray-800 mb-3">Analytics</h3> <div className="grid grid-cols-2 sm:grid-cols-4 gap-3"> <div className="bg-gray-50 p-3 rounded-lg text-center"> <div className="text-2xl font-bold text-gray-800">{analytics?.sessionCount || 0}</div> <div className="text-xs text-gray-600">Sessions</div> </div> <div className="bg-gray-50 p-3 rounded-lg text-center"> <div className="text-2xl font-bold text-gray-800">{analytics?.taggedSessionCount || 0}</div> <div className="text-xs text-gray-600">Tagged</div> </div> <div className="bg-gray-50 p-3 rounded-lg text-center"> <div className="text-2xl font-bold text-gray-800">{analytics?.totalShares || 0}</div> <div className="text-xs text-gray-600">Shares</div> </div> <div className="bg-gray-50 p-3 rounded-lg text-center"> <div className="text-2xl font-bold text-gray-800">{analytics?.deliveryCount || 0}</div> <div className="text-xs text-gray-600">Deliveries</div> </div> </div> </div> {/* Timeline */} <div className="p-6 border-b border-gray-200"> <h3 className="font-semibold text-gray-800 mb-2">Timeline</h3> <div className="space-y-2 text-sm"> <p className="text-gray-600"> Created: {formatDate(customer.createdAt, true)} </p> {customer.lastContactAt && ( <p className="text-gray-600"> Last Contact: {formatRelativeTime(customer.lastContactAt)} </p> )} </div> </div> {/* Sessions */} <div className="p-6"> <div className="flex items-center justify-between mb-3"> <h3 className="font-semibold text-gray-800"> Sessions ({customer.sessions?.length || 0}) </h3> {customer.sessions?.length > 0 && ( <button onClick={() => navigate(`/gallery?customer=${customerId}`)} className="text-sm text-primary hover:text-blue-600" > View All ‚Üí </button> )} </div> {customer.sessions && customer.sessions.length > 0 ? ( <div className="grid grid-cols-3 sm:grid-cols-6 gap-2"> {customer.sessions.slice(0, 6).map(session => ( <div key={session.sessionId} onClick={() => navigate(`/share/${session.sessionId}`)} className=" aspect-square bg-gray-100 rounded-lg overflow-hidden cursor-pointer hover:ring-2 hover:ring-primary transition-all " > {sessionThumbs[session.sessionId] && ( <img src={sessionThumbs[session.sessionId]} alt={session.imageName} className="w-full h-full object-cover" /> )} </div> ))} </div> ) : ( <p className="text-gray-500 text-sm text-center py-4"> No sessions yet </p> )} </div> {/* Notes */} {customer.notes && ( <div className="p-6 bg-gray-50 border-t border-gray-200"> <h3 className="font-semibold text-gray-800 mb-2">Notes</h3> <p className="text-sm text-gray-600 whitespace-pre-wrap">{customer.notes}</p> </div> )} </div> );}export default CustomerDetail;

Notes: Comprehensive view with analytics; session thumbnails; click-to-navigate.

FILE: /src/components/crm/CustomerEditor.jsx





javascript

// File: /src/components/crm/CustomerEditor.jsx// Purpose: Form for creating/editing customers// Connects to: CRMPage, CustomerStoreimport React, { useState, useEffect } from 'react';import { getCustomer, addCustomer, updateCustomer } from '../../services/CustomerStore';import useDebug from '../../debug/useDebug';function CustomerEditor({ customerId, onSave, onCancel }) { const debug = useDebug('CRM'); const [formData, setFormData] = useState({ name: '', phone: '', email: '', notes: '' }); const [isSubmitting, setIsSubmitting] = useState(false); const [error, setError] = useState(null); useEffect(() => { if (customerId) { loadCustomer(); } }, [customerId]); const loadCustomer = async () => { try { const customer = await getCustomer(customerId); if (customer) { setFormData({ name: customer.name || '', phone: customer.phone || '', email: customer.email || '', notes: customer.notes || '' }); } } catch (err) { debug.error('load_customer_failed', { customerId, error: err.message }); } }; const handleChange = (e) => { const { name, value } = e.target; setFormData(prev => ({ ...prev, [name]: value })); }; const handleSubmit = async (e) => { e.preventDefault(); setError(null); // Validation if (!formData.name.trim()) { setError('Name is required'); return; } setIsSubmitting(true); debug.log('save_start', { customerId, isNew: !customerId }); try { if (customerId) { // Update existing await updateCustomer(customerId, formData); debug.success('customer_updated', { customerId }); } else { // Create new const newId = await addCustomer(formData); debug.success('customer_created', { customerId: newId }); } onSave(); } catch (err) { setError(err.message); debug.error('save_failed', { customerId, error: err.message }); setIsSubmitting(false); } }; return ( <div className="bg-white rounded-lg shadow-md p-6"> <h2 className="text-xl font-bold text-gray-800 mb-4"> {customerId ? 'Edit Customer' : 'New Customer'} </h2> <form onSubmit={handleSubmit} className="space-y-4"> {error && ( <div className="p-3 bg-red-50 border-l-4 border-red-500 text-red-700 text-sm"> {error} </div> )} <div> <label className="block text-sm font-medium text-gray-700 mb-1"> Name * </label> <input type="text" name="name" value={formData.name} onChange={handleChange} required className=" w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base min-h-[44px] " placeholder="Customer name" /> </div> <div> <label className="block text-sm font-medium text-gray-700 mb-1"> Phone </label> <input type="tel" name="phone" value={formData.phone} onChange={handleChange} className=" w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base min-h-[44px] " placeholder="(555) 123-4567" /> </div> <div> <label className="block text-sm font-medium text-gray-700 mb-1"> Email </label> <input type="email" name="email" value={formData.email} onChange={handleChange} className=" w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base min-h-[44px] " placeholder="customer@example.com" /> </div> <div> <label className="block text-sm font-medium text-gray-700 mb-1"> Notes </label> <textarea name="notes" value={formData.notes} onChange={handleChange} rows="4" className=" w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-primary focus:ring-1 focus:ring-primary focus:outline-none text-base resize-none " placeholder="Additional notes..." /> </div> {/* Actions */} <div className="flex flex-col-reverse sm:flex-row gap-3 pt-4"> <button type="button" onClick={onCancel} disabled={isSubmitting} className=" flex-1 px-4 py-3 border-2 border-gray-300 text-gray-700 rounded-lg font-medium hover:bg-gray-50 active:bg-gray-100 disabled:opacity-50 transition-colors text-base min-h-[48px] touch-manipulation " > Cancel </button> <button type="submit" disabled={isSubmitting} className=" flex-1 px-4 py-3 bg-primary text-white rounded-lg font-medium hover:bg-blue-600 active:bg-blue-700 disabled:bg-gray-300 transition-colors text-base min-h-[48px] touch-manipulation " > {isSubmitting ? 'Saving...' : 'Save Customer'} </button> </div> </form> </div> );}export default CustomerEditor;

Notes: Form validation; handles both create and edit modes; auto-saves tags.

üîÑ INTEGRATION UPDATES

Update TaggingPage CustomerModal





javascript

// In /src/components/tagging/CustomerModal.jsx// Add after customer creation/lookup:import { linkSessionToCustomer } from '../../../services/SessionStore';// Inside handleSubmit, after customer is found/created:await linkSessionToCustomer(sessionId, customerId);

Update SharePage Header





javascript

// In /src/pages/SharePage.jsx// Add customer info display in header:const [customerInfo, setCustomerInfo] = useState(null);useEffect(() => { if (session?.customerId) { getCustomer(session.customerId).then(setCustomerInfo); }}, [session]);// In header JSX:{customerInfo && ( <p className="text-xs text-gray-500"> üë§ {customerInfo.name} </p>)}

üìã PHASE 4 SUMMARY

‚úÖ Files Created/Updated (13)

Updated Services (3):



/src/services/database.js - Version 3 with customer linking

/src/services/SessionStore.js - Customer-aware queries

/src/services/CustomerStore.js - Enhanced search

New Services (2):

4. /src/services/CRMService.js - Analytics and aggregations

5. /src/hooks/useSearchFilter.js - Reusable search/filter hook

Updated Pages (1):

6. /src/pages/GalleryPage.jsx - Enhanced with filters and customer info

New Pages (1):

7. /src/pages/CRMPage.jsx - Complete CRM interface

Gallery Components (3):

8. /src/components/gallery/FilterBar.jsx - Search and filter controls

9. /src/components/gallery/GridView.jsx - Responsive grid layout

10. /src/components/gallery/SessionCard.jsx - Enhanced session cards

CRM Components (3):

11. /src/components/crm/CustomerList.jsx - Customer list view

12. /src/components/crm/CustomerDetail.jsx - Customer details with analytics

13. /src/components/crm/CustomerEditor.jsx - Customer form

üéØ Features Implemented

Gallery Enhancements:



‚úÖ Advanced filtering (status, date, customer)

‚úÖ Real-time search with debouncing

‚úÖ Grid/list view toggle

‚úÖ Customer name display on cards

‚úÖ Enhanced session cards with actions

‚úÖ EventBus reactivity

CRM System:



‚úÖ Customer CRUD operations

‚úÖ Master-detail layout

‚úÖ Customer analytics dashboard

‚úÖ Session history per customer

‚úÖ Search with partial matching

‚úÖ Customer merging capability

Data Integration:



‚úÖ Session-to-customer linking

‚úÖ Customer search tags (indexed)

‚úÖ Analytics aggregation layer

‚úÖ Cross-store queries

üóÑÔ∏è Database Changes

Version 3 Schema:



Added customerId to photoSessions

Added customerId to deliveryJobs

Added tags array to customers (searchable)

Added lastContactAt to customers

Migration path from v2

üìä Data Flow





Upload ‚Üí Tag ‚Üí Link Customer ‚Üí Share ‚Üì CRM Store ‚Üì Analytics Service ‚Üì Gallery Display

üöÄ Phase 5 Preparation Notes

Server Sync Ready:



All stores use consistent ID patterns

EventBus provides sync points

Analytics can be cached/computed

Customer merging handles duplicates

API Gateway Considerations:



Sessions need upload endpoint

Customers need CRUD endpoints

Analytics can be server-computed

Deliveries need webhook handlers

Offline-First Architecture:



All data in IndexedDB

EventBus for local changes

Sync queue for pending uploads

Conflict resolution needed

‚ö†Ô∏è Migration Guide

From Phase 3 to Phase 4:



Database migration runs automatically on page load

Existing sessions get customerId: null initially

Customer tags auto-populate on first edit

No data loss - all Phase 3 sessions remain intact

Testing checklist:



Existing sessions load correctly

Customer linking works in TaggingPage

Gallery shows customer names

CRM analytics calculate properly

Search finds customers by all fields

EventBus updates all views

üß™ Testing Scenarios

Gallery Enhancement:Upload session ‚Üí verify appears in gallery

Link customer ‚Üí verify name shows on card

Search by filename ‚Üí verify filtering

Toggle grid/list view ‚Üí verify layout

CRM Integration:Create customer ‚Üí verify appears in list

Link to session ‚Üí verify in customer detail

Edit customer ‚Üí verify tags update

View analytics ‚Üí verify calculations

Cross-Module:Tag session with customer ‚Üí verify in CRM

Delete customer ‚Üí verify sessions unlink

Search customer ‚Üí verify in gallery filter

‚úÖ Phase 4 Claude Architect Planning Complete

Total files: 13

Database version: 3

New features: Gallery filters, CRM system, customer linking

Ready for: Gemini Review ‚Üí Grok Implementation ‚Üí Phase 5 (Server Sync)