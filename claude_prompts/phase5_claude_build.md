PMC REVAMP ‚Äî PHASE 5: INSTAGRAM-STYLE TAGGING FLOW REBUILD
Generated by Claude (Architect AI)
Date: 2025-10-12

üì¶ PHASE 5 OVERVIEW
Rebuilding the tagging system with Instagram-native UX:

One-click tag placement with live text input
Intuitive drag-and-drop repositioning
Clean marker-based visual design
Local overlay vs. physical burn modes
Simplified data model (x, y, text only)
Touch-optimized interactions

Components: 3
Services: 1
User Flow: Click ‚Üí Place ‚Üí Type ‚Üí Done

üéØ DESIGN PHILOSOPHY
Instagram-Style Tagging:

Immediate visual feedback
Minimal UI chrome
Spatial awareness (click exactly where tag should appear)
Live text rendering on image
No complex editing panels

Technical Approach:

Percentage-based positioning (responsive)
State-driven rendering (React controlled)
Canvas compositing for burn mode
Pointer events for universal touch/mouse support


üìä DATA MODEL
javascript// Simplified tag structure
Tag = {
  id: string,           // UUID for React keys
  text: string,         // User-entered label (@username)
  xPct: number,         // 0-100 (percentage of image width)
  yPct: number,         // 0-100 (percentage of image height)
  createdAt: number,    // Timestamp
  isEditing: boolean    // True when input is active
}

// Tag modes
TagMode = 'local' | 'physical'
// local: Tags stored in metadata, overlaid at view time
// physical: Tags burned into exported image file

FILE: /src/components/tagging/SocialTagger.jsx
javascript// File: /src/components/tagging/SocialTagger.jsx
// Purpose: Instagram-style tag placement and management system
// Connects to: TagMarker.jsx, TagModeSelector.jsx, TagCanvasService.js, SessionStore

import React, { useState, useRef, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import useDebug from '../../debug/useDebug';
import { getSession, updateTagsMeta } from '../../services/SessionStore';
import { blobToDataURL } from '../../services/ImageService';
import { generateUUID, pixelsToPct, pctToPixels } from '../../utils/helpers';
import TagMarker from './TagMarker';
import TagModeSelector from './TagModeSelector';
import { burnTagsToImage } from '../../services/TagCanvasService';

function SocialTagger() {
  const { sessionId } = useParams();
  const navigate = useNavigate();
  const debug = useDebug('TAGGING');

  // Refs
  const imageRef = useRef(null);
  const containerRef = useRef(null);

  // State
  const [session, setSession] = useState(null);
  const [imageUrl, setImageUrl] = useState(null);
  const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 });
  const [tags, setTags] = useState([]);
  const [isPlacementMode, setIsPlacementMode] = useState(false);
  const [tagMode, setTagMode] = useState('local'); // 'local' or 'physical'
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  // Load session and image
  useEffect(() => {
    loadSession();
    return () => {
      if (imageUrl) URL.revokeObjectURL(imageUrl);
    };
  }, [sessionId]);

  // Track image dimensions for positioning
  useEffect(() => {
    const updateDimensions = () => {
      if (imageRef.current) {
        const rect = imageRef.current.getBoundingClientRect();
        setImageDimensions({ width: rect.width, height: rect.height });
      }
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, [imageUrl]);

  const loadSession = async () => {
    debug.time('load_tagging_session');
    try {
      const sessionData = await getSession(sessionId);
      if (!sessionData) throw new Error('Session not found');

      setSession(sessionData);
      
      // Load existing tags or initialize empty
      const existingTags = sessionData.tagsMeta || [];
      setTags(existingTags.map(tag => ({
        ...tag,
        isEditing: false
      })));

      // Convert blob to URL
      const url = await blobToDataURL(sessionData.rawImageBlob);
      setImageUrl(url);

      debug.timeEnd('load_tagging_session', { sessionId, tagCount: existingTags.length });
      setIsLoading(false);
    } catch (error) {
      debug.error('load_failed', { sessionId, error: error.message });
      setIsLoading(false);
    }
  };

  /**
   * Enter placement mode - next click on image will place a tag
   */
  const handleAddTag = () => {
    debug.log('placement_mode_activated');
    setIsPlacementMode(true);
  };

  /**
   * Handle click on image to place new tag
   */
  const handleImageClick = (e) => {
    if (!isPlacementMode) return;

    const rect = imageRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Convert to percentage
    const xPct = pixelsToPct(x, rect.width);
    const yPct = pixelsToPct(y, rect.height);

    // Create new tag
    const newTag = {
      id: generateUUID(),
      text: '',
      xPct: Math.max(0, Math.min(100, xPct)),
      yPct: Math.max(0, Math.min(100, yPct)),
      createdAt: Date.now(),
      isEditing: true // Start in edit mode
    };

    setTags(prev => [...prev, newTag]);
    setIsPlacementMode(false);
    debug.log('tag_placed', { tagId: newTag.id, xPct, yPct });
  };

  /**
   * Update tag text (live as user types)
   */
  const handleTagTextChange = (tagId, text) => {
    setTags(prev => prev.map(tag =>
      tag.id === tagId ? { ...tag, text } : tag
    ));
  };

  /**
   * Complete tag editing
   */
  const handleTagComplete = (tagId) => {
    setTags(prev => prev.map(tag =>
      tag.id === tagId ? { ...tag, isEditing: false } : tag
    ));
    debug.log('tag_completed', { tagId });
  };

  /**
   * Delete tag
   */
  const handleDeleteTag = (tagId) => {
    setTags(prev => prev.filter(tag => tag.id !== tagId));
    debug.log('tag_deleted', { tagId });
  };

  /**
   * Update tag position (from drag)
   */
  const handleTagMove = (tagId, xPct, yPct) => {
    setTags(prev => prev.map(tag =>
      tag.id === tagId ? { ...tag, xPct, yPct } : tag
    ));
  };

  /**
   * Save tags to database
   */
  const handleSaveTags = async () => {
    debug.time('save_tags');
    setIsSaving(true);

    try {
      // Filter out empty tags and remove isEditing flag
      const tagsToSave = tags
        .filter(tag => tag.text.trim())
        .map(({ id, text, xPct, yPct, createdAt }) => ({
          id,
          text,
          xPct,
          yPct,
          type: 'instagram',
          createdAt,
          fontSize: 24,
          color: '#FFFFFF',
          backgroundColor: 'rgba(0, 0, 0, 0.6)',
          logoScale: 1.0,
          shadow: true
        }));

      await updateTagsMeta(sessionId, tagsToSave);
      debug.timeEnd('save_tags', { sessionId, count: tagsToSave.length });
      debug.success('tags_saved', { count: tagsToSave.length });
      
      return tagsToSave;
    } catch (error) {
      debug.error('save_failed', { error: error.message });
      throw error;
    } finally {
      setIsSaving(false);
    }
  };

  /**
   * Navigate to share page
   */
  const handleContinue = async () => {
    try {
      await handleSaveTags();
      navigate(`/share/${sessionId}`);
    } catch (error) {
      // Error already logged
    }
  };

  /**
   * Export with burned tags (physical mode)
   */
  const handleExportPhysical = async () => {
    debug.time('burn_tags');
    setIsSaving(true);

    try {
      const savedTags = await handleSaveTags();
      
      // Burn tags into image
      const burnedDataUrl = await burnTagsToImage(imageUrl, savedTags, imageDimensions);
      
      // Trigger download
      const a = document.createElement('a');
      a.href = burnedDataUrl;
      a.download = `${session.imageName}_tagged.jpg`;
      a.click();

      debug.timeEnd('burn_tags', { sessionId, tagCount: savedTags.length });
      debug.success('tags_burned', { sessionId });
    } catch (error) {
      debug.error('burn_failed', { error: error.message });
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center text-white">
          <div className="text-5xl mb-4">‚è≥</div>
          <p>Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-900 flex flex-col">
      {/* Header */}
      <div className="bg-gray-800 border-b border-gray-700 p-4">
        <div className="flex items-center justify-between">
          <button
            onClick={() => navigate('/gallery')}
            className="text-gray-300 hover:text-white min-h-[44px] min-w-[44px]"
          >
            ‚Üê Back
          </button>
          <h1 className="text-white font-semibold">üè∑Ô∏è Tag Photo</h1>
          <button
            onClick={handleContinue}
            disabled={isSaving}
            className="
              px-4 py-2 bg-primary text-white rounded-lg font-medium
              hover:bg-blue-600 disabled:bg-gray-600 transition-colors
              text-sm min-h-[44px]
            "
          >
            {isSaving ? 'Saving...' : 'Continue'}
          </button>
        </div>
      </div>

      {/* Image Canvas */}
      <div 
        ref={containerRef}
        className="flex-1 flex items-center justify-center p-4 overflow-hidden"
      >
        <div className="relative max-w-full max-h-full">
          <img
            ref={imageRef}
            src={imageUrl}
            alt="Tagging canvas"
            onClick={handleImageClick}
            className={`
              max-w-full max-h-[60vh] w-auto h-auto object-contain
              ${isPlacementMode ? 'cursor-crosshair' : 'cursor-default'}
              select-none
            `}
            draggable={false}
          />

          {/* Tag Overlays */}
          {tags.map(tag => (
            <TagMarker
              key={tag.id}
              tag={tag}
              imageDimensions={imageDimensions}
              onTextChange={(text) => handleTagTextChange(tag.id, text)}
              onComplete={() => handleTagComplete(tag.id)}
              onDelete={() => handleDeleteTag(tag.id)}
              onMove={(xPct, yPct) => handleTagMove(tag.id, xPct, yPct)}
            />
          ))}

          {/* Placement Mode Indicator */}
          {isPlacementMode && (
            <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
              <div className="bg-black bg-opacity-75 text-white px-6 py-3 rounded-lg text-sm">
                üìç Click on image to place tag
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Controls */}
      <div className="bg-gray-800 border-t border-gray-700 p-4 space-y-3">
        {/* Mode Selector */}
        <TagModeSelector
          mode={tagMode}
          onModeChange={setTagMode}
        />

        {/* Action Buttons */}
        <div className="flex gap-3">
          <button
            onClick={handleAddTag}
            disabled={isPlacementMode || isSaving}
            className="
              flex-1 px-4 py-3 bg-primary text-white rounded-lg font-medium
              hover:bg-blue-600 disabled:bg-gray-600 transition-colors
              min-h-[52px] touch-manipulation
            "
          >
            {isPlacementMode ? 'üìç Click Image to Place' : '+ Add Tag'}
          </button>

          {tagMode === 'physical' && (
            <button
              onClick={handleExportPhysical}
              disabled={tags.length === 0 || isSaving}
              className="
                flex-1 px-4 py-3 bg-green-600 text-white rounded-lg font-medium
                hover:bg-green-700 disabled:bg-gray-600 transition-colors
                min-h-[52px] touch-manipulation
              "
            >
              üíæ Export with Tags
            </button>
          )}
        </div>

        {/* Tag Count */}
        <p className="text-center text-gray-400 text-sm">
          {tags.length} tag{tags.length !== 1 ? 's' : ''} added
        </p>
      </div>
    </div>
  );
}

export default SocialTagger;
Notes: Single-click placement flow; percentage-based positioning; dual-mode export support.

FILE: /src/components/tagging/TagMarker.jsx
javascript// File: /src/components/tagging/TagMarker.jsx
// Purpose: Individual tag marker with live text input and drag support
// Connects to: SocialTagger.jsx

import React, { useState, useRef, useEffect } from 'react';
import { pctToPixels, pixelsToPct } from '../../utils/helpers';

function TagMarker({ tag, imageDimensions, onTextChange, onComplete, onDelete, onMove }) {
  const markerRef = useRef(null);
  const inputRef = useRef(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

  // Auto-focus input when tag is in edit mode
  useEffect(() => {
    if (tag.isEditing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [tag.isEditing]);

  const { width, height } = imageDimensions;
  const x = pctToPixels(tag.xPct, width);
  const y = pctToPixels(tag.yPct, height);

  /**
   * Handle pointer down for drag
   */
  const handlePointerDown = (e) => {
    if (tag.isEditing) return; // Don't drag while editing

    e.stopPropagation();
    
    const rect = markerRef.current.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    setDragOffset({ x: offsetX, y: offsetY });
    setIsDragging(true);
    markerRef.current.setPointerCapture(e.pointerId);
  };

  /**
   * Handle pointer move for drag
   */
  const handlePointerMove = (e) => {
    if (!isDragging) return;

    e.stopPropagation();

    // Get parent container (image) position
    const imageRect = markerRef.current.parentElement.getBoundingClientRect();
    
    // Calculate new position relative to image
    const newX = e.clientX - imageRect.left - dragOffset.x;
    const newY = e.clientY - imageRect.top - dragOffset.y;

    // Convert to percentage and clamp
    const xPct = Math.max(0, Math.min(100, pixelsToPct(newX, width)));
    const yPct = Math.max(0, Math.min(100, pixelsToPct(newY, height)));

    onMove(xPct, yPct);
  };

  /**
   * Handle pointer up to end drag
   */
  const handlePointerUp = (e) => {
    if (!isDragging) return;

    setIsDragging(false);
    if (markerRef.current.hasPointerCapture(e.pointerId)) {
      markerRef.current.releasePointerCapture(e.pointerId);
    }
  };

  /**
   * Handle text input
   */
  const handleInputChange = (e) => {
    onTextChange(e.target.value);
  };

  /**
   * Handle input completion
   */
  const handleInputBlur = () => {
    onComplete();
  };

  /**
   * Handle Enter key
   */
  const handleInputKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onComplete();
    }
  };

  /**
   * Handle delete
   */
  const handleDeleteClick = (e) => {
    e.stopPropagation();
    onDelete();
  };

  return (
    <div
      ref={markerRef}
      className={`
        absolute pointer-events-auto touch-none select-none
        ${isDragging ? 'z-50' : 'z-10'}
        ${tag.isEditing ? '' : 'cursor-move'}
      `}
      style={{
        left: `${x}px`,
        top: `${y}px`,
        transform: 'translate(-50%, -50%)'
      }}
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
    >
      {/* Tag Marker Dot */}
      <div className="relative">
        <div
          className={`
            w-8 h-8 rounded-full flex items-center justify-center
            transition-all
            ${tag.isEditing 
              ? 'bg-primary animate-pulse ring-2 ring-white' 
              : 'bg-gradient-to-br from-pink-500 to-purple-600'
            }
          `}
        >
          {!tag.isEditing && (
            <span className="text-white text-xs font-bold">@</span>
          )}
        </div>

        {/* Text Display (when not editing) */}
        {!tag.isEditing && tag.text && (
          <div className="absolute top-full left-1/2 -translate-x-1/2 mt-2 whitespace-nowrap">
            <div
              className="
                px-3 py-1 rounded-lg text-white text-sm font-medium
                bg-black bg-opacity-75 backdrop-blur-sm
                shadow-lg
              "
            >
              {tag.text}
            </div>
          </div>
        )}

        {/* Input (when editing) */}
        {tag.isEditing && (
          <div className="absolute top-full left-1/2 -translate-x-1/2 mt-2">
            <input
              ref={inputRef}
              type="text"
              value={tag.text}
              onChange={handleInputChange}
              onBlur={handleInputBlur}
              onKeyDown={handleInputKeyDown}
              placeholder="@username"
              className="
                px-3 py-1 rounded-lg text-white text-sm font-medium
                bg-gray-900 border-2 border-primary
                focus:outline-none focus:ring-2 focus:ring-primary
                min-w-[120px]
              "
              maxLength={30}
            />
          </div>
        )}

        {/* Delete Button */}
        {!tag.isEditing && (
          <button
            onClick={handleDeleteClick}
            className="
              absolute -top-2 -right-2
              w-6 h-6 rounded-full bg-red-500 text-white
              flex items-center justify-center text-xs
              hover:bg-red-600 active:bg-red-700
              transition-colors shadow-lg
              pointer-events-auto cursor-pointer
            "
          >
            ‚úï
          </button>
        )}
      </div>
    </div>
  );
}

export default TagMarker;
Notes: Instagram gradient dot; live input; touch-optimized drag; auto-focus on creation.

FILE: /src/components/tagging/TagModeSelector.jsx
javascript// File: /src/components/tagging/TagModeSelector.jsx
// Purpose: Toggle between local overlay and physical burn modes
// Connects to: SocialTagger.jsx

import React from 'react';

function TagModeSelector({ mode, onModeChange }) {
  return (
    <div className="flex items-center justify-center gap-4 p-3 bg-gray-750 rounded-lg">
      <span className="text-sm text-gray-400 font-medium">Tag Mode:</span>
      
      <div className="flex bg-gray-800 rounded-lg p-1">
        <button
          onClick={() => onModeChange('local')}
          className={`
            px-4 py-2 rounded-md text-sm font-medium transition-all
            min-h-[40px] touch-manipulation
            ${mode === 'local'
              ? 'bg-primary text-white shadow-sm'
              : 'text-gray-400 hover:text-white'
            }
          `}
        >
          üìã Local Overlay
        </button>
        
        <button
          onClick={() => onModeChange('physical')}
          className={`
            px-4 py-2 rounded-md text-sm font-medium transition-all
            min-h-[40px] touch-manipulation
            ${mode === 'physical'
              ? 'bg-primary text-white shadow-sm'
              : 'text-gray-400 hover:text-white'
            }
          `}
        >
          üî• Burn Into Image
        </button>
      </div>

      {/* Mode Description */}
      <div className="hidden sm:block">
        {mode === 'local' ? (
          <p className="text-xs text-gray-500">
            Tags stored in metadata (reversible)
          </p>
        ) : (
          <p className="text-xs text-gray-500">
            Tags permanently embedded in image
          </p>
        )}
      </div>
    </div>
  );
}

export default TagModeSelector;
Notes: Clear visual distinction; tooltip descriptions; responsive hide on mobile.

FILE: /src/services/TagCanvasService.js
javascript// File: /src/services/TagCanvasService.js
// Purpose: Canvas-based tag burning into image files
// Connects to: SocialTagger.jsx, SharePage.jsx

import { pctToPixels } from '../utils/helpers';

/**
 * Burn tags permanently into image
 * @param {string} imageDataUrl - Base64 data URL of image
 * @param {Array} tags - Array of tag objects with xPct, yPct, text
 * @param {Object} imageDimensions - Current display dimensions for scaling
 * @returns {Promise<string>} Data URL of image with burned tags
 */
export async function burnTagsToImage(imageDataUrl, tags, imageDimensions) {
  return new Promise((resolve, reject) => {
    const img = new Image();

    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Use full image resolution
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;

        // Draw base image
        ctx.drawImage(img, 0, 0);

        // Calculate scale factor (display ‚Üí actual)
        const scaleX = img.naturalWidth / imageDimensions.width;
        const scaleY = img.naturalHeight / imageDimensions.height;

        // Draw each tag
        tags.forEach(tag => {
          if (!tag.text) return;

          // Convert percentage to actual pixels on full-res image
          const x = (tag.xPct / 100) * canvas.width;
          const y = (tag.yPct / 100) * canvas.height;

          drawInstagramTag(ctx, x, y, tag.text, scaleX);
        });

        // Convert to data URL
        const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
        resolve(dataUrl);
      } catch (error) {
        reject(error);
      }
    };

    img.onerror = () => {
      reject(new Error('Failed to load image for burning'));
    };

    img.src = imageDataUrl;
  });
}

/**
 * Draw Instagram-style tag on canvas
 * @param {CanvasRenderingContext2D} ctx
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {string} text - Tag text
 * @param {number} scale - Scale factor for proportional sizing
 */
function drawInstagramTag(ctx, x, y, text, scale = 1) {
  ctx.save();

  // Scaled dimensions
  const dotSize = 32 * scale;
  const padding = 12 * scale;
  const fontSize = 24 * scale;
  const logoSize = 24 * scale;

  // Draw dot marker
  ctx.beginPath();
  ctx.arc(x, y, dotSize / 2, 0, Math.PI * 2);
  const gradient = ctx.createLinearGradient(x - dotSize / 2, y, x + dotSize / 2, y);
  gradient.addColorStop(0, '#f09433');
  gradient.addColorStop(0.25, '#e6683c');
  gradient.addColorStop(0.5, '#dc2743');
  gradient.addColorStop(0.75, '#cc2366');
  gradient.addColorStop(1, '#bc1888');
  ctx.fillStyle = gradient;
  ctx.fill();

  // Draw @ symbol on dot
  ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${fontSize * 0.6}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('@', x, y);

  // Draw text label below dot
  const textY = y + dotSize / 2 + padding + fontSize / 2;
  
  // Background
  ctx.font = `bold ${fontSize}px Arial`;
  const textWidth = ctx.measureText(text).width;
  const bgWidth = textWidth + padding * 2;
  const bgHeight = fontSize + padding;

  ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
  ctx.beginPath();
  ctx.roundRect(
    x - bgWidth / 2,
    textY - fontSize / 2 - padding / 2,
    bgWidth,
    bgHeight,
    8 * scale
  );
  ctx.fill();

  // Text with shadow
  ctx.fillStyle = '#FFFFFF';
  ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
  ctx.shadowBlur = 4 * scale;
  ctx.shadowOffsetX = 2 * scale;
  ctx.shadowOffsetY = 2 * scale;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, textY);

  ctx.restore();
}

/**
 * Create Instagram logo as small circle (alternative to @)
 * @param {CanvasRenderingContext2D} ctx
 * @param {number} x
 * @param {number} y
 * @param {number} size
 */
function drawInstagramLogo(ctx, x, y, size) {
  ctx.save();

  // Gradient circle
  const gradient = ctx.createRadialGradient(x, y, 0, x, y, size / 2);
  gradient.addColorStop(0, '#f09433');
  gradient.addColorStop(0.25, '#e6683c');
  gradient.addColorStop(0.5, '#dc2743');
  gradient.addColorStop(0.75, '#cc2366');
  gradient.addColorStop(1, '#bc1888');

  ctx.beginPath();
  ctx.arc(x, y, size / 2, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // White @ symbol
  ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${size * 0.6}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('@', x, y);

  ctx.restore();
}

/**
 * Polyfill for roundRect (not available in all browsers)
 */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
    this.moveTo(x + radius, y);
    this.lineTo(x + width - radius, y);
    this.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.lineTo(x + width, y + height - radius);
    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.lineTo(x + radius, y + height);
    this.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.lineTo(x, y + radius);
    this.quadraticCurveTo(x, y, x + radius, y);
    this.closePath();
  };
}

export default {
  burnTagsToImage
};
Notes: Proportional scaling; Instagram gradient; canvas polyfill for roundRect; high-quality JPEG export.

üé® VISUAL DESIGN SPEC
Tag Marker States
Placement Mode:

Crosshair cursor over image
"Click to place" overlay message
No existing tags affected

New Tag (Editing):

Pulsing blue dot with ring
Auto-focused input field below
No delete button visible
Cannot be dragged

Completed Tag:

Instagram gradient dot (pink‚Üípurple)
White @ symbol in center
Text label below in black capsule
Small red ‚úï button top-right
Draggable with move cursor

Dragging:

Higher z-index (appears on top)
Follows pointer smoothly
Clamped to image boundaries


üîÑ STATE FLOW DIAGRAM
Initial Load
     ‚Üì
Load Image + Existing Tags
     ‚Üì
Display Tags (read-only)
     ‚Üì
User clicks "Add Tag"
     ‚Üì
Enter Placement Mode
     ‚Üì
User clicks on image
     ‚Üì
Create Tag at % position
     ‚Üì
Show Input (isEditing: true)
     ‚Üì
User types ‚Üí Live Update
     ‚Üì
Press Enter / Blur
     ‚Üì
Complete Tag (isEditing: false)
     ‚Üì
Tag becomes draggable
     ‚Üì
[Loop: Add more tags or continue]
     ‚Üì
Click "Continue"
     ‚Üì
Save to SessionStore
     ‚Üì
Navigate to Share

Alternative: "Export Physical"
     ‚Üì
Burn tags via TagCanvasService
     ‚Üì
Download burned image

üì± MOBILE OPTIMIZATION
Touch Interactions:

Tap precision: 44px minimum tap targets
Drag threshold: 10px movement before drag starts
Momentum: Smooth pointer tracking with no lag
Zoom: Allow pinch-zoom on image (tags scale with it)

Responsive Layout:

Image scales to max-h-[60vh]
Controls panel fixed at bottom
Input fields use native mobile keyboards
No hover states (use active states)

Gesture Support:

Single tap: Place tag (placement mode) or select tag
Drag: Move tag
Tap ‚úï: Delete tag
Tap outside input: Complete editing


üß™ TESTING SCENARIOS

Basic Flow:

Click "Add Tag" ‚Üí Click image ‚Üí Type text ‚Üí Press Enter
Verify tag appears at exact click location
Verify text shows below marker


Multiple Tags:

Add 3-5 tags to different positions
Verify no overlap or z-index issues
Verify each can be dragged independently


Edge Cases:

Click near image edge ‚Üí Verify clamping works
Delete tag while others exist ‚Üí Verify IDs stable
Resize window ‚Üí Verify tags reposition correctly


Mode Switching:

Add tags in local mode
Switch to physical mode
Export ‚Üí Verify burned tags at correct positions


Save/Load:

Add tags ‚Üí Save ‚Üí Navigate away
Return to tagging page
Verify tags persist and display correctly




üîó INTEGRATION WITH EXISTING SYSTEM
Update TaggingPage.jsx
javascript// Replace entire TaggingPage with SocialTagger component
import SocialTagger from '../components/tagging/SocialTagger';

function TaggingPage() {
  return <SocialTagger />;
}
Update SharePage.jsx
javascript// Add physical burn option using TagCanvasService
import { burnTagsToImage } from '../services/TagCanvasService';

// In handleExport function:
if (settings.autoWatermark && currentVersion === 'tagged') {
  const burnedUrl = await burnTagsToImage(previewUrl, session.tagsMeta, dimensions);
  // Use burnedUrl for download
}

üì¶ DEPENDENCIES
New:

None (uses existing helpers and canvas API)

Updated Helpers:
javascript// Ensure these exist in /src/utils/helpers.js
- generateUUID()
- pctToPixels(pct, dimension)
- pixelsToPct(pixels, dimension)

‚ö†Ô∏è MIGRATION NOTES
From Phase 3 to Phase 5:

Data Model Change:

Old: Multiple fields (fontSize, color, backgroundColor, etc.)
New: Simplified (id, text, xPct, yPct only)
Migration: Existing tags will load but only use position + text


Component Replacement:

Replace: ImageStage, SocialTagger (old), TagInputPanel
Keep: CustomerModal (unchanged)


Behavior Change:

Old: Click tag ‚Üí Edit in panel
New: Click "Add Tag" ‚Üí Click image ‚Üí Type inline


Backward Compatibility:

TagCanvasService can read old tag format
Converts to simplified format on save




‚úÖ Tagging Flow Architecture Complete
Components: 3
Services: 1
User Flow: Click ‚Üí Place ‚Üí Type ‚Üí Done
Mobile: Fully touch-optimized
Modes: Local overlay + Physical burn
Ready for: Gemini Review ‚Üí Grok Implementation ‚Üí Phase 6 (Settings & Polish)